<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pytorch深度学习总结.md</title>
      <link href="/2022/11/09/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-md/"/>
      <url>/2022/11/09/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-md/</url>
      
        <content type="html"><![CDATA[<h2 id="深度学习流程"><a href="#深度学习流程" class="headerlink" title="深度学习流程"></a>深度学习流程</h2><h3 id="流程简述"><a href="#流程简述" class="headerlink" title="流程简述"></a>流程简述</h3><pre class="mermaid">graph TD a[Build the dataset]-->b[preprocessing] b[preprocessing]-->c[training and validation] c-->d[Parameter tuning && optimization]</pre><h3 id="构建数据集："><a href="#构建数据集：" class="headerlink" title="构建数据集："></a>构建数据集：</h3><ol><li>流程</li></ol><p>first step: 收集数据：去大量抽样调查收集，爬虫（<a href="https://github.com/MrS0m30n3/youtube-dl-gui">youtube爬虫工具</a>），众包（<del>花钱找工具人</del>）等等</p><p>second: 数据格式整理</p><p>third: 导入代码进行处理</p><ol start="2"><li><p>code</p><p>一般处理csv或者json等格式的文本格式文件，下为举例</p><p>sklearn</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_json(<span class="string">&#x27;data.json&#x27;</span>)</span><br><span class="line"><span class="comment"># data = pd.read_csv(&#x27;data.csv&#x27;)</span></span><br></pre></td></tr></table></figure><p>pytorch</p><p>​pytorch的项目预处理的时候可以用pandas、json等库处理，之后生成新的文件在构建模型前构造DataSet和DataLoader时直接读取数据集来load</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train_dataset = MyDataset(csv_file=<span class="string">&#x27;../data/data.csv&#x27;</span>,</span><br><span class="line">root_dir=<span class="string">&#x27;../data&#x27;</span>,</span><br><span class="line">transform=torchvision.transforms.ToTensor())</span><br></pre></td></tr></table></figure></li></ol><h3 id="数据集划分："><a href="#数据集划分：" class="headerlink" title="数据集划分："></a>数据集划分：</h3><ol><li>基本知识</li></ol><ul><li><p>训练集（Train Set）: 模型用于训练和调整模型参数</p></li><li><p>验证集（Validation Set）: 用来验证模型精度和调整</p></li><li><p>测试集（Test Set）: 验证模型的泛化能力</p></li></ul><blockquote><p>训练集和验证集有时候是从同一数据集中分开的，但是在划分验证集时需要注意验证集的分布需和测试集尽量保持一致，保证其泛化性</p></blockquote><p>几种划分方式：</p><ul><li><p>留出法（Hold-Out）：直接将训练集划分为新的训练集和验证集。优点简单。缺点只得到了一份验证集，有可能导致模型在验证集上过拟合，适用于数据量比较大点的情况。</p></li><li><p>交叉验证法（Cross Validation,CV）：将训练集划分成K份，将其中的K-1份作为训练集，剩余的1份作为验证集，循环K训练。这种划分方式是所有的训练集都是验证集，最终模型验证精度是K份平均得到。这种方式的优点是验证集精度比较可靠，训练K次可以得到K个有多样性差异的模型；CV验证的缺点是需要训练K次，不适合数据量很大的情况。</p></li><li><p>自助采样法（BootStrap）：通过有放回的采样方式得到新的训练集和验证集，每次的训练集和验证集都是有区别的。这种划分方式一般适用于数据量较小的情况。</p></li></ul><ol start="2"><li><p>code: </p><p>sklearn</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"></span><br><span class="line">os.chdir(<span class="string">&#x27;breast_cancer_data&#x27;</span>)</span><br><span class="line">data = pd.read_csv(<span class="string">r&#x27;data.csv&#x27;</span>)</span><br><span class="line">data.drop(<span class="string">&#x27;Unnamed: 32&#x27;</span>,inplace = <span class="literal">True</span>,axis = <span class="number">1</span>)</span><br><span class="line">data.drop(<span class="string">&#x27;id&#x27;</span>,inplace = <span class="literal">True</span>,axis=<span class="number">1</span>)</span><br><span class="line">y = data[<span class="string">&#x27;diagnosis&#x27;</span>]</span><br><span class="line">x = data.drop(<span class="string">&#x27;diagnosis&#x27;</span>,axis = <span class="number">1</span>)</span><br><span class="line">model = RandomForestClassifier()</span><br></pre></td></tr></table></figure><p>留出法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">14x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.33</span>, random_state=<span class="number">42</span>)</span><br></pre></td></tr></table></figure><p>k折交叉验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line">kf = KFold(n_splits = <span class="number">10</span>)</span><br><span class="line">accuracy = []</span><br><span class="line"><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> kf.split(x):</span><br><span class="line">     x_train, x_test = x.loc[train_index],x.loc[test_index]</span><br><span class="line">     y_train, y_test = y.loc[train_index],y.loc[test_index]</span><br><span class="line">     model.fit(x_train, y_train)</span><br><span class="line">     prediction = model.predict(x_test)</span><br><span class="line">     acc=metrics.accuracy_score(predocton, y_test)</span><br><span class="line">     accuracy,append(acc)</span><br><span class="line"><span class="built_in">print</span>(accuracy)</span><br><span class="line"><span class="built_in">print</span>(np.average(accuracy))</span><br></pre></td></tr></table></figure><p>pytorch:</p><p><strong>torch.utils.data.Subset</strong>或者<strong>random_split</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_dataset, test_dataset = torch.utils.data.random_split(full_dataset, [train_size, test_size])</span><br></pre></td></tr></table></figure><p>或者自定义分类数据集</p><p>eg: 文本分类中可以根据文本数字先进行排序然后按照顺序每10个前9个放入训练集后1个放入测试集(若为9:1)，然后训练时再进行shuffle，这样保证了分布均匀的问题</p></li></ol><h3 id="模型训练和验证"><a href="#模型训练和验证" class="headerlink" title="模型训练和验证"></a>模型训练和验证</h3><ol><li><p>仔细检查数据：</p><p>花时间去检查数据是一件比较重要的工作。因为数据中往往可能存在异常值，而且了解它们的分布可以有利于我们找到一个更好的模型。同时也可以对数据进行一开始的手动调整。</p></li><li><p>搭建模型并开始训练验证</p><p>评估框架提示</p><ul><li>固定随机种子：始终使用固定的随机种子来确保两次运行代码时，您将获得相同的结果。</li><li>简化：去除不必要的一些操作</li><li>验证损失：验证损失是否从正确的损失值开始</li><li>设定一个好的初始化</li><li>人类基线：监控除损失之外的指标，这些指标是人类可以解释和检查的（例如准确性）。尽可能评估自己（人类）的准确性并与之进行比较。</li><li>可视化预测动态。训练过程中可视化固定测试批次上的模型预测对模型调整有很大帮助。</li></ul></li><li><p>过度拟合</p></li></ol><p>找到一个好的模型的方法有两个阶段：首先获得一个足够大的模型以使其可以过度拟合（即专注于训练损失），然后适当地对其进行正则化（放弃一些训练损失以提高验证损失）。</p><p>此阶段的一些提示和技巧：</p><ul><li>选择模型：为了减少训练损失，您需要为数据选择合适的体系结构。</li><li>Adam是安全的。在设定基准的早期阶段，我喜欢以3e-4的学习率使用Adam 。以我的经验，亚当更宽容超参数，包括不良的学习速度。对于ConvNets，调整良好的SGD几乎总是比Adam稍胜一筹，但是最佳学习率区域要狭窄得多且针对特定问题。</li><li>一次只使一个复杂化。如果您有多个信号要插入您的分类器，我建议您将它们一个接一个地插入，并每次确保获得预期的性能提升。</li><li>不要相信学习率衰减的默认值。如果您要重新使用其他领域的代码，请务必小心学习率。</li></ul><p><strong>4. 正则化</strong></p><p>此阶段的一些提示和技巧：</p><ul><li>获取更多数据</li><li>数据扩充</li><li>创意增强：如果半假数据没有做到这一点，伪造数据也可能会有所作为。人们正在寻找扩展数据集的创新方法。例如，领域随机化，模拟的使用，巧妙的混合，例如将（潜在模拟的）数据插入场景，甚至GAN。</li><li>使用预训练网络</li><li>坚持监督学习</li><li>减小输入维数</li><li>减小模型尺寸</li><li>减小批量大小</li><li>Dropout</li><li>提早停止训练。根据您测得的验证损失提前停止训练，以在模型快要过拟合的时候捕获模型。</li><li>尝试更大的模型。大型模型大多数最终会过拟合，但是它们的“早期停止”性能通常会比小型模型好得多。</li></ul><p><strong>5. 微调</strong></p><p>此阶段的一些提示和技巧：</p><ul><li>随机网格搜索</li><li>超参数优化</li></ul><p><strong>6. 进一步提高精确率</strong></p><ul><li>模型集成</li></ul><p>代码参考搭建过的一些项目</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>github fork仓库向主工程提交代码</title>
      <link href="/2022/09/22/github-fork%E4%BB%93%E5%BA%93%E5%90%91%E4%B8%BB%E5%B7%A5%E7%A8%8B%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81/"/>
      <url>/2022/09/22/github-fork%E4%BB%93%E5%BA%93%E5%90%91%E4%B8%BB%E5%B7%A5%E7%A8%8B%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-fork并关联本地"><a href="#1-fork并关联本地" class="headerlink" title="1. fork并关联本地"></a>1. fork并关联本地</h2><p>进入我的主页，找到这个仓库</p><p><img src="https://haoming2003.oss-cn-hangzhou.aliyuncs.com/202209220208551.png" alt="image-20220922020848487"></p><p>点击右上角的fork，然后你的主页里就多了一个同样的仓库了，相当于做了一个镜像开了个分支</p><p>然后在本地合适位置（最好别带中文）建立一个同名文件夹（名字不影响，但是为了一致嘛），然后在文件夹中打开git bash(path配置好了的话，powershell也可以)，然后按照如下流程输入（有梯子的话最好打开梯子）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆fork后仓库到本地,yourname为你的github名</span></span><br><span class="line">git <span class="built_in">clone</span> （fork后的url）</span><br></pre></td></tr></table></figure><p>然后你的文件夹下就会出现本项目已有所有文件，然后你就可以在本地仓库的对应文件夹（你的名字）添加你的学习文件了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add到本地暂存区, .是add所有新文件的意思</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># commit到本地仓库</span></span><br><span class="line">git commit -m <span class="string">&quot;first_commit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关联到你的远程仓库</span></span><br><span class="line">git remote add origin your_url</span><br><span class="line"></span><br><span class="line"><span class="comment"># push到你的远程仓库</span></span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p><img src="https://haoming2003.oss-cn-hangzhou.aliyuncs.com/202209220214651.webp" alt="img"></p><p>然后你fork的仓库会出现你的新增文件</p><h2 id="2-关联主工程"><a href="#2-关联主工程" class="headerlink" title="2.关联主工程"></a>2.关联主工程</h2><p>关联主工程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add okex(自定义分支名) (主工程的git url)</span><br><span class="line"><span class="comment"># 查看关联情况</span></span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p><img src="https://haoming2003.oss-cn-hangzhou.aliyuncs.com/202209220224884.png" alt="在这里插入图片描述"></p><p>拉取主工程各分支信息到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch okex(自定义分支名)</span><br></pre></td></tr></table></figure><p><img src="https://haoming2003.oss-cn-hangzhou.aliyuncs.com/202209220224876.png" alt="在这里插入图片描述"></p><p>在本地切换到主分支的某分支（比如develop）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br></pre></td></tr></table></figure><p>在此分支的基础上创建一个自己的分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b michael.w</span><br></pre></td></tr></table></figure><p>开始做代码修改。</p><p>代码commit后向自己的repo push代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p>这里可能报错，请根据报错内容自行纠正</p><p><img src="https://haoming2003.oss-cn-hangzhou.aliyuncs.com/202209220224883.png" alt="在这里插入图片描述"></p><ol><li>从自己的repo中向主工程发起request pull：<br><img src="https://haoming2003.oss-cn-hangzhou.aliyuncs.com/202209220224879.png" alt="在这里插入图片描述"><br>选择要提交的目标分支：<br><img src="https://haoming2003.oss-cn-hangzhou.aliyuncs.com/202209220224980.png" alt="在这里插入图片描述"></li></ol><h3 id="如何将主分支的更新进度同步到我的repo中"><a href="#如何将主分支的更新进度同步到我的repo中" class="headerlink" title="如何将主分支的更新进度同步到我的repo中"></a>如何将主分支的更新进度同步到我的repo中</h3><p>假设主工程的开发分支时main</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切到本地的main分支</span></span><br><span class="line">git checkout main</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将okex的的main分支拉取下来并与本地现在所处分支合并</span></span><br><span class="line">git pull okex main</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推到我的repo</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>本文参考了<a href="https://blog.csdn.net/michael_wgy_/article/details/104589800">wgy的博客</a>，侵删</strong></p></blockquote><blockquote><p><strong>由于github默认分支改变，以上master记得改为main</strong></p></blockquote><hr>]]></content>
      
      
      
        <tags>
            
            <tag> github fork 上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github+hexo+butterfly搭建博客</title>
      <link href="/2022/09/21/github-hexo-butterfly%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/09/21/github-hexo-butterfly%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<hr><p>突然想到搭建一个博客玩，其实之前也在csdn上发过一点，但是没坚持下来，太失败了</p><p>希望这次可以坚持下来，下面记录一下搭建过程</p><hr><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><p>github账号</p></li><li><p>nodejs, npm（版本别太低）</p></li></ol><p>上网搜具体的安装教程，肯定比我写得好</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="创建username-github-io的项目"><a href="#创建username-github-io的项目" class="headerlink" title="创建username.github.io的项目"></a>创建<strong>username.github.io</strong>的项目</h4><p>（记住<strong>username</strong>跟你<strong>github</strong>名称同名）</p><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，我的放在<code>D:\blog</code>下</p><p><strong>在该目录下</strong></p><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装<strong>Hexo</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-cli -g</span><br></pre></td></tr></table></figure><p>可能会有几个报错，忽略</p><p>安装完后用 <strong>hexo -v</strong> 验证是否安装成功</p><h4 id="初始化并生成网页"><a href="#初始化并生成网页" class="headerlink" title="初始化并生成网页"></a><strong>初始化</strong>并生成网页</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">npm install <span class="comment"># 安装必备组件</span></span><br><span class="line"></span><br><span class="line">hexo g <span class="comment"># 生成静态网页</span></span><br><span class="line"></span><br><span class="line">hexo s <span class="comment"># 打开本地服务器,打开http://localhost:4000/,就有效果了</span></span><br></pre></td></tr></table></figure><p><strong>ctrl</strong> + <strong>c</strong>关闭本地服务器</p><h4 id="连接github和本地"><a href="#连接github和本地" class="headerlink" title="连接github和本地"></a>连接github和本地</h4><p>在根目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;HaomingX&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;978545377@qq.com&quot;</span></span><br><span class="line"><span class="comment"># 根据你注册github的信息替换成你自己的</span></span><br></pre></td></tr></table></figure><p>生成密钥SSH key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;978545377@qq.com&quot;</span></span><br></pre></td></tr></table></figure><p>打开<a href="http://github.com/">github</a>，点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字任意</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>复制到ssh密匙框中，保存</p><p>输入<code>ssh -T git@github.com</code>，如果说了Hi 用户名!,你就成功了</p><p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件</p><p>修改最后一行的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/HaomingX/HaomingX.github.io</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><h4 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h4><p>根目录下安装扩展</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-deployer-git</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文章</span></span><br><span class="line">hexo new post <span class="string">&quot;文章名&quot;</span></span><br></pre></td></tr></table></figure><p>打开<code>D:\blog\source\_posts</code>的目录，可以发现下面多了一个<code>.md</code>文件</p><p>编写完后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">hexo d <span class="comment"># 上传到github</span></span><br></pre></td></tr></table></figure><p>打开你的<a href="https://github.io/">github.io</a>主页就能看到发布的文章</p><h3 id="butterfly美化"><a href="#butterfly美化" class="headerlink" title="butterfly美化"></a>butterfly美化</h3><p><a href="https://tzy1997.com/articles/hexo1603/">可以跟这个博主的教程走，写得很好</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
